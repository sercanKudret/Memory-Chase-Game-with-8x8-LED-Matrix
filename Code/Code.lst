CCS PCM C Compiler, Version 5.007, 61971               28-Kas-23 06:39

               Filename:   C:\Users\Sercan\Desktop\Training Kit\Code\Code.lst

               ROM used:   1352 words (17%)
                           Largest free fragment is 2048
               RAM used:   110 (30%) at main() level
                           129 (35%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   4E9
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0004:  BSF    03.5
0005:  MOVF   4A,W
0006:  ANDLW  07
0007:  MOVWF  77
0008:  RRF    4A,W
0009:  MOVWF  78
000A:  RRF    78,F
000B:  RRF    78,F
000C:  MOVLW  1F
000D:  ANDWF  78,F
000E:  MOVF   78,W
000F:  ADDWF  4C,W
0010:  MOVWF  04
0011:  BCF    03.7
0012:  BTFSC  4D.0
0013:  BSF    03.7
0014:  CLRF   78
0015:  INCF   78,F
0016:  INCF   77,F
0017:  GOTO   019
0018:  RLF    78,F
0019:  DECFSZ 77,F
001A:  GOTO   018
001B:  MOVF   4B,F
001C:  BTFSC  03.2
001D:  GOTO   021
001E:  MOVF   78,W
001F:  IORWF  00,F
0020:  GOTO   024
0021:  COMF   78,F
0022:  MOVF   78,W
0023:  ANDWF  00,F
0024:  BCF    03.5
0025:  RETURN
0026:  BSF    03.5
0027:  MOVF   4A,W
0028:  ANDLW  07
0029:  MOVWF  77
002A:  RRF    4A,W
002B:  MOVWF  78
002C:  RRF    78,F
002D:  RRF    78,F
002E:  MOVLW  1F
002F:  ANDWF  78,F
0030:  MOVF   78,W
0031:  ADDWF  4B,W
0032:  MOVWF  04
0033:  BCF    03.7
0034:  BTFSC  4C.0
0035:  BSF    03.7
0036:  MOVF   00,W
0037:  MOVWF  78
0038:  INCF   77,F
0039:  GOTO   03B
003A:  RRF    78,F
003B:  DECFSZ 77,F
003C:  GOTO   03A
003D:  BCF    03.5
003E:  BCF    0A.3
003F:  BCF    0A.4
0040:  GOTO   092 (RETURN)
*
01FE:  MOVLW  20
01FF:  MOVWF  52
0200:  CLRF   4E
0201:  CLRF   4F
0202:  CLRF   50
0203:  CLRF   51
0204:  MOVF   49,W
0205:  MOVWF  7A
0206:  MOVF   48,W
0207:  MOVWF  79
0208:  MOVF   47,W
0209:  MOVWF  78
020A:  MOVF   46,W
020B:  MOVWF  77
020C:  BCF    03.0
020D:  BTFSS  77.0
020E:  GOTO   21D
020F:  MOVF   4A,W
0210:  ADDWF  4E,F
0211:  MOVF   4B,W
0212:  BTFSC  03.0
0213:  INCFSZ 4B,W
0214:  ADDWF  4F,F
0215:  MOVF   4C,W
0216:  BTFSC  03.0
0217:  INCFSZ 4C,W
0218:  ADDWF  50,F
0219:  MOVF   4D,W
021A:  BTFSC  03.0
021B:  INCFSZ 4D,W
021C:  ADDWF  51,F
021D:  RRF    51,F
021E:  RRF    50,F
021F:  RRF    4F,F
0220:  RRF    4E,F
0221:  RRF    7A,F
0222:  RRF    79,F
0223:  RRF    78,F
0224:  RRF    77,F
0225:  DECFSZ 52,F
0226:  GOTO   20C
*
025E:  CLRF   78
025F:  CLRF   79
0260:  CLRF   77
0261:  CLRF   7A
0262:  MOVF   4C,W
0263:  BTFSS  03.2
0264:  GOTO   268
0265:  MOVF   4B,W
0266:  BTFSC  03.2
0267:  GOTO   282
0268:  MOVLW  10
0269:  MOVWF  4D
026A:  BCF    03.0
026B:  RLF    49,F
026C:  RLF    4A,F
026D:  RLF    77,F
026E:  RLF    7A,F
026F:  MOVF   4C,W
0270:  SUBWF  7A,W
0271:  BTFSS  03.2
0272:  GOTO   275
0273:  MOVF   4B,W
0274:  SUBWF  77,W
0275:  BTFSS  03.0
0276:  GOTO   27E
0277:  MOVF   4B,W
0278:  SUBWF  77,F
0279:  BTFSS  03.0
027A:  DECF   7A,F
027B:  MOVF   4C,W
027C:  SUBWF  7A,F
027D:  BSF    03.0
027E:  RLF    78,F
027F:  RLF    79,F
0280:  DECFSZ 4D,F
0281:  GOTO   26A
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
051F:  CLRF   20
0520:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01E7:  MOVF   25,W
01E8:  BSF    03.5
01E9:  MOVWF  49
01EA:  BCF    03.5
01EB:  MOVF   24,W
01EC:  BSF    03.5
01ED:  MOVWF  48
01EE:  BCF    03.5
01EF:  MOVF   23,W
01F0:  BSF    03.5
01F1:  MOVWF  47
01F2:  BCF    03.5
01F3:  MOVF   22,W
01F4:  BSF    03.5
01F5:  MOVWF  46
01F6:  MOVLW  41
01F7:  MOVWF  4D
01F8:  MOVLW  C6
01F9:  MOVWF  4C
01FA:  MOVLW  4E
01FB:  MOVWF  4B
01FC:  MOVLW  6D
01FD:  MOVWF  4A
*
0227:  MOVF   7A,W
0228:  MOVWF  49
0229:  MOVF   79,W
022A:  MOVWF  48
022B:  MOVF   78,W
022C:  MOVWF  47
022D:  MOVF   77,W
022E:  MOVWF  46
022F:  MOVLW  39
0230:  ADDWF  46,W
0231:  BCF    03.5
0232:  MOVWF  22
0233:  BSF    03.5
0234:  MOVF   47,W
0235:  BCF    03.5
0236:  MOVWF  23
0237:  MOVLW  30
0238:  BTFSC  03.0
0239:  MOVLW  31
023A:  ADDWF  23,F
023B:  BSF    03.5
023C:  MOVF   48,W
023D:  BCF    03.5
023E:  MOVWF  24
023F:  MOVLW  00
0240:  BTFSC  03.0
0241:  MOVLW  01
0242:  ADDWF  24,F
0243:  BSF    03.5
0244:  MOVF   49,W
0245:  BCF    03.5
0246:  MOVWF  25
0247:  MOVLW  00
0248:  BTFSC  03.0
0249:  MOVLW  01
024A:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
024B:  MOVF   24,W
024C:  MOVWF  77
024D:  MOVF   25,W
024E:  MOVWF  78
024F:  CLRF   79
0250:  CLRF   7A
0251:  MOVF   78,W
0252:  BSF    03.5
0253:  MOVWF  48
0254:  MOVF   77,W
0255:  MOVWF  47
0256:  MOVF   48,W
0257:  MOVWF  4A
0258:  MOVF   47,W
0259:  MOVWF  49
025A:  MOVLW  7F
025B:  MOVWF  4C
025C:  MOVLW  FF
025D:  MOVWF  4B
*
0282:  MOVF   77,W
0283:  MOVWF  78
0284:  MOVF   7A,W
0285:  MOVWF  79
0286:  BCF    03.5
0287:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
02EC:  MOVF   49,W
02ED:  BCF    03.5
02EE:  MOVWF  25
02EF:  BSF    03.5
02F0:  MOVF   48,W
02F1:  BCF    03.5
02F2:  MOVWF  24
02F3:  BSF    03.5
02F4:  MOVF   47,W
02F5:  BCF    03.5
02F6:  MOVWF  23
02F7:  BSF    03.5
02F8:  MOVF   46,W
02F9:  BCF    03.5
02FA:  MOVWF  22
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=4000000) 
*
0288:  MOVLW  C6
0289:  MOVWF  04
028A:  BCF    03.7
028B:  MOVF   00,W
028C:  BTFSC  03.2
028D:  GOTO   29C
028E:  MOVLW  01
028F:  MOVWF  78
0290:  CLRF   77
0291:  DECFSZ 77,F
0292:  GOTO   291
0293:  DECFSZ 78,F
0294:  GOTO   290
0295:  MOVLW  4A
0296:  MOVWF  77
0297:  DECFSZ 77,F
0298:  GOTO   297
0299:  GOTO   29A
029A:  DECFSZ 00,F
029B:  GOTO   28E
029C:  RETURN
....................  
.................... #define DIN    PIN_B0 
.................... #define LOAD   PIN_B1 
.................... #define CLK    PIN_B2 
.................... #define BUZZER PIN_B3 
....................  
.................... #define BUTTON_UP     PIN_D2 
.................... #define BUTTON_DOWN   PIN_D4 
.................... #define BUTTON_LEFT   PIN_D1 
.................... #define BUTTON_RIGHT  PIN_D3 
.................... #define BUTTON_SELECT PIN_D0 
....................  
....................  
.................... #include <MAX7219.c> 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <STDLIBM.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... #define clk_delay 1 
.................... #byte    SSPCON1  =     0xFC6 
.................... #bit     SSPEN    =     SSPCON1.5 
....................  
....................  
.................... #define FIRST_CHAR 32 
.................... #define LAST_CHAR 125 
.................... #define char_spacing 1 
.................... unsigned int8 cur_scroll_position=0; 
.................... unsigned int16 cur_letter_position=0; 
.................... unsigned int16 cur_letter_end_position=0; 
.................... unsigned int8 temp_char_spacing=0; 
.................... char* scroll_chars; 
.................... BYTE cur_char_data[8]={0,0,0,0,0,0,0,0}; 
*
0521:  CLRF   30
0522:  CLRF   31
0523:  CLRF   32
0524:  CLRF   33
0525:  CLRF   34
0526:  CLRF   35
0527:  CLRF   36
0528:  CLRF   37
.................... unsigned int8 scroll_text_len=0; 
.................... BYTE const font_width[]={ 
....................     0x07, 0x01, 0x03, 0x05, 0x05, 0x07, 0x07, 0x01, 0x03, 0x03,  
....................     0x05, 0x07, 0x02, 0x05, 0x02, 0x03,  
....................     0x05, 0x03, 0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05,  
....................     0x02, 0x02, 0x07, 0x06, 0x07, 0x05, 0x08,  
....................     0x07, 0x05, 0x05, 0x05, 0x05, 0x04, 0x06, 0x05, 0x01, 0x04, 
....................     0x06, 0x05, 0x07, 0x05, 0x06, 0x05, 0x06, 0x05, 0x05, 0x05, 
....................     0x05, 0x07, 0x07, 0x07, 0x07, 0x06, 
....................     0x03, 0x03, 0x03, 0x05, 0x06, 0x02, 0x04, 0x04, 0x04, 0x04,  
....................     0x04, 0x03, 0x04, 0x04, 0x01, 0x03, 0x04, 0x01, 0x07, 0x04,  
....................     0x04, 0x04, 0x04, 0x03, 0x04, 0x03, 0x04, 0x05, 0x07, 0x05,  
....................     0x05, 0x05, 0x03, 0x01, 0x03, 
.................... }; 
....................  
.................... BYTE const font[]={ 
....................     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 
....................     0xBE, // 33 
....................     0x0E, 0x00, 0x0E, // 34 
....................     0xE8, 0x3C, 0xEA, 0x3C, 0x2A, // 35 
....................     0x4C, 0x92, 0xFE, 0x92, 0x64, // 36 
....................     0x0C, 0x12, 0xCC, 0x30, 0x6C, 0x92, 0x60, // 37 
....................     0x60, 0x94, 0x9A, 0xAA, 0x44, 0xE0, 0xA0, // 38 
....................     0x0E, // 39 
....................     0x38, 0x44, 0x82, // 40 
....................     0x82, 0x44, 0x38, // 41 
....................     0x22, 0x14, 0x3E, 0x14, 0x22, // 42 
....................     0x10, 0x10, 0x10, 0xFE, 0x10, 0x10, 0x10, // 43 
....................     0x80, 0x60, // 44 
....................     0x10, 0x10, 0x10, 0x10, 0x10, // 45 
....................     0x60, 0x60, // 46 
....................     0xC0, 0x38, 0x06, // 47 
....................     0x7C, 0x82, 0x82, 0x82, 0x7C, // 48 
....................     0x08, 0x04, 0xFE, // 49 
....................     0x84, 0xC2, 0xA2, 0x92, 0x8C, // 50 
....................     0x44, 0x82, 0x92, 0x92, 0x6C, // 51 
....................     0x30, 0x28, 0x24, 0x22, 0xFE, 0x20, // 52 
....................     0x4C, 0x8A, 0x8A, 0x8A, 0x72, // 53 
....................     0x7C, 0x92, 0x92, 0x92, 0x64, // 54 
....................     0x02, 0xC2, 0x32, 0x0A, 0x06, // 55 
....................     0x6C, 0x92, 0x92, 0x92, 0x6C, // 56 
....................     0x4C, 0x92, 0x92, 0x92, 0x7C, // 57 
....................     0x66, 0x66, // 58 
....................     0xA6, 0x66, // 59 
....................     0x08, 0x08, 0x14, 0x14, 0x22, 0x22, 0x41, // 60 
....................     0x24, 0x24, 0x24, 0x24, 0x24, 0x24, // 61 
....................     0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, // 62 
....................     0x0C, 0x02, 0xA2, 0x12, 0x0C, // 63 
....................     0x38, 0x44, 0x82, 0x99, 0x99, 0xA1, 0x22, 0x1C, // 64     
....................     0x80, 0x70, 0x2C, 0x22, 0x2C, 0x70, 0x80, // 65 
....................     0xFE, 0x92, 0x92, 0x92, 0x7C, // 66 
....................     0x7C, 0x82, 0x82, 0x82, 0x44, // 67 
....................     0xFE, 0x82, 0x82, 0x44, 0x38, // 68 
....................     0xFE, 0x92, 0x92, 0x92, 0x92, // 69 
....................     0xFE, 0x12, 0x12, 0x02, // 70 
....................     0x38, 0x44, 0x82, 0x92, 0x54, 0x30, // 71 
....................     0xFE, 0x10, 0x10, 0x10, 0xFE, // 72 
....................     0xFE, // 73 
....................     0xC0, 0x80, 0x80, 0x7E, // 74 
....................     0xFE, 0x20, 0x10, 0x28, 0x44, 0x82, // 75 
....................     0xFE, 0x80, 0x80, 0x80, 0x80, // 76 
....................     0xFE, 0x0C, 0x70, 0x80, 0x70, 0x0C, 0xFE, // 77 
....................     0xFE, 0x0C, 0x10, 0x60, 0xFE, // 78 
....................     0x7C, 0x82, 0x82, 0x82, 0x82, 0x7C, // 79 
....................     0xFE, 0x12, 0x12, 0x12, 0x0C, // 80 
....................     0x7C, 0x82, 0x82, 0xC2, 0xC2, 0xBC, // 81 
....................     0xFE, 0x12, 0x12, 0x32, 0xCC, // 82 
....................     0x4C, 0x92, 0x92, 0x92, 0x64, // 83 
....................     0x02, 0x02, 0xFE, 0x02, 0x02, // 84 
....................     0x7E, 0x80, 0x80, 0x80, 0x7E, // 85 
....................     0x02, 0x1C, 0x60, 0x80, 0x60, 0x1C, 0x02, // 86 
....................     0x7E, 0x80, 0x80, 0x70, 0x80, 0x80, 0x7E, // 87 
....................     0x80, 0x42, 0x24, 0x18, 0x24, 0x42, 0x80, // 88 
....................     0x02, 0x04, 0x08, 0xF0, 0x08, 0x04, 0x02, // 89 
....................     0xC2, 0xA2, 0x92, 0x8A, 0x86, 0x82, // 90 
....................     0x7F, 0x41, 0x41, // 91 
....................     0x03, 0x1C, 0x60, // 92 
....................     0x41, 0x41, 0x7F, // 93 
....................     0x08, 0x06, 0x01, 0x06, 0x08, // 94 
....................     0x80, 0x80, 0x80, 0x80, 0x80, 0x80, // 95 
....................     0x04, 0x03, // 96 
....................     0x60, 0x54, 0x54, 0x7C, // 97 
....................     0x7F, 0x48, 0x48, 0x30, // 98 
....................     0x38, 0x44, 0x44, 0x28, // 99 
....................     0x30, 0x48, 0x48, 0x7F, // 100 
....................     0x38, 0x54, 0x54, 0x58, // 101 
....................     0x08, 0x7E, 0x09, // 102 
....................     0x4C, 0x92, 0x92, 0x7E, // 103 
....................     0x7F, 0x08, 0x08, 0x70, // 104 
....................     0x7D, // 105 
....................     0x20, 0x40, 0x3D, // 106 
....................     0x7F, 0x10, 0x38, 0x44, // 107 
....................     0x7F, // 108 
....................     0x7E, 0x02, 0x02, 0x7E, 0x02, 0x02, 0x7C, // 109 
....................     0x7E, 0x02, 0x02, 0x7C, // 110 
....................     0x3C, 0x42, 0x42, 0x3C, // 111 
....................     0xFE, 0x22, 0x22, 0x1C, // 112 
....................     0x1C, 0x22, 0x22, 0xFE, // 113 
....................     0x7C, 0x08, 0x04, // 114 
....................     0x48, 0x54, 0x54, 0x24, // 115 
....................     0x08, 0x7F, 0x48, // 116 
....................     0x3C, 0x40, 0x40, 0x7C, // 117 
....................     0x02, 0x1C, 0x20, 0x1C, 0x02, // 118 
....................     0x1E, 0x20, 0x1C, 0x02, 0x1C, 0x20, 0x1E, // 119 
....................     0x22, 0x14, 0x08, 0x14, 0x22, // 120 
....................     0x02, 0x9C, 0x60, 0x1C, 0x02, // 121 
....................     0x44, 0x64, 0x54, 0x4C, 0x44, // 122 
....................     0x08, 0x36, 0x41, // 123 
....................     0xFF, // 124 
....................     0x41, 0x36, 0x08 // 125     
....................     }; 
.................... BYTE const numbers[]={0x3F,0x30,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F}; 
.................... int1 nd; 
.................... unsigned int8 pos1; 
.................... //concat two 8bit int and gives a 16 bit int 
.................... //helper function 
.................... unsigned int16 concat(unsigned int8 d1,unsigned int8 d2) 
.................... { 
....................    unsigned int16 temp; 
....................    temp=0x0000; 
*
00A5:  CLRF   49
00A6:  CLRF   48
....................    temp=d1; 
00A7:  CLRF   49
00A8:  MOVF   46,W
00A9:  MOVWF  48
....................    shift_left(&temp,2,0); 
00AA:  BCF    03.0
00AB:  RLF    48,F
00AC:  RLF    49,F
....................    shift_left(&temp,2,0); 
00AD:  BCF    03.0
00AE:  RLF    48,F
00AF:  RLF    49,F
....................    shift_left(&temp,2,0); 
00B0:  BCF    03.0
00B1:  RLF    48,F
00B2:  RLF    49,F
....................    shift_left(&temp,2,0); 
00B3:  BCF    03.0
00B4:  RLF    48,F
00B5:  RLF    49,F
....................    shift_left(&temp,2,0); 
00B6:  BCF    03.0
00B7:  RLF    48,F
00B8:  RLF    49,F
....................    shift_left(&temp,2,0); 
00B9:  BCF    03.0
00BA:  RLF    48,F
00BB:  RLF    49,F
....................    shift_left(&temp,2,0); 
00BC:  BCF    03.0
00BD:  RLF    48,F
00BE:  RLF    49,F
....................    shift_left(&temp,2,0); 
00BF:  BCF    03.0
00C0:  RLF    48,F
00C1:  RLF    49,F
....................    //temp=temp&0x0111; 
....................    temp=temp|d2; 
00C2:  MOVF   47,W
00C3:  IORWF  48,F
....................    return temp; 
00C4:  MOVF   48,W
00C5:  MOVWF  78
00C6:  MOVF   49,W
00C7:  MOVWF  79
.................... } 
.................... //since the segment sequence of MAX7219 is 
.................... //D7 D6 D5 D4 D3 D2 D1 D0 
.................... //DP  A  B  C  D  E  F  G   while according to convention it is 
.................... //DP  G  F  E  D  C  B  A 
.................... //One may avoide this my doing the proper changes in the circuit wiring but 
.................... //it will again lead to more complication because in CODE B decode mode the 
.................... //segment are just opposit to what u see in no decode mode. so in any case 
.................... //one need to use this helper function if he wants to use the chip in both 
.................... //no decode and decode modes. 
.................... unsigned int8 reverse(unsigned int8 nd_data) 
.................... { 
....................    int1 D[8]; 
....................    unsigned int8 i; 
....................    unsigned int8 temp; 
....................    for(i=0;i<8;i++) 
*
004B:  CLRF   48
004C:  MOVF   48,W
004D:  SUBLW  07
004E:  BTFSS  03.0
004F:  GOTO   06A
....................    { 
....................       if(shift_left(&nd_data, 1, 0)) 
0050:  BCF    03.0
0051:  RLF    46,F
0052:  BTFSS  03.0
0053:  GOTO   05F
....................          D[i]=1; 
0054:  MOVF   48,W
0055:  MOVWF  4A
0056:  MOVLW  01
0057:  MOVWF  4B
0058:  CLRF   4D
0059:  MOVLW  C7
005A:  MOVWF  4C
005B:  BCF    03.5
005C:  CALL   004
005D:  GOTO   067
005E:  BSF    03.5
....................       else 
....................          D[i]=0; 
005F:  MOVF   48,W
0060:  MOVWF  4A
0061:  CLRF   4B
0062:  CLRF   4D
0063:  MOVLW  C7
0064:  MOVWF  4C
0065:  BCF    03.5
0066:  CALL   004
0067:  BSF    03.5
0068:  INCF   48,F
0069:  GOTO   04C
....................    } 
....................    temp=D[1]; 
006A:  CLRF   49
006B:  BTFSC  47.1
006C:  INCF   49,F
....................    D[1]=D[7]; 
006D:  BCF    47.1
006E:  BTFSC  47.7
006F:  BSF    47.1
....................    D[7]=temp; 
0070:  BCF    47.7
0071:  BTFSC  49.0
0072:  BSF    47.7
....................  
....................    temp=D[2]; 
0073:  CLRF   49
0074:  BTFSC  47.2
0075:  INCF   49,F
....................    D[2]=D[6]; 
0076:  BCF    47.2
0077:  BTFSC  47.6
0078:  BSF    47.2
....................    D[6]=temp; 
0079:  BCF    47.6
007A:  BTFSC  49.0
007B:  BSF    47.6
....................  
....................    temp=D[3]; 
007C:  CLRF   49
007D:  BTFSC  47.3
007E:  INCF   49,F
....................    D[3]=D[5]; 
007F:  BCF    47.3
0080:  BTFSC  47.5
0081:  BSF    47.3
....................    D[5]=temp; 
0082:  BCF    47.5
0083:  BTFSC  49.0
0084:  BSF    47.5
....................  
....................    temp=0x00; 
0085:  CLRF   49
....................    for(i=0;i<8;i++) 
0086:  CLRF   48
0087:  MOVF   48,W
0088:  SUBLW  07
0089:  BTFSS  03.0
008A:  GOTO   09B
....................       shift_left(&temp,1,D[i]); 
008B:  MOVF   48,W
008C:  MOVWF  4A
008D:  CLRF   4C
008E:  MOVLW  C7
008F:  MOVWF  4B
0090:  BCF    03.5
0091:  GOTO   026
0092:  BTFSC  78.0
0093:  GOTO   096
0094:  BCF    03.0
0095:  GOTO   097
0096:  BSF    03.0
0097:  BSF    03.5
0098:  RLF    49,F
0099:  INCF   48,F
009A:  GOTO   087
....................  
....................    return temp; 
009B:  MOVF   49,W
009C:  MOVWF  78
.................... } 
.................... //Quite self explanatory 
.................... //it displays a data at the address given 
.................... //1 -> 1st digit 
.................... //8 -> 8th digit 
.................... //and dis_data is the data that is to be displayed there 
.................... void display(char adresse,char dis_data) 
.................... { 
....................  char x; 
....................  unsigned int16 dout; 
....................  SSPEN=0; 
*
0041:  BSF    03.5
0042:  BSF    03.6
0043:  BCF    46.5
....................  if(nd==0) 
0044:  BCF    03.5
0045:  BCF    03.6
0046:  BTFSC  39.0
0047:  GOTO   0A0
....................    dis_data=reverse(dis_data); 
0048:  BSF    03.5
0049:  MOVF   42,W
004A:  MOVWF  46
*
009D:  MOVF   78,W
009E:  MOVWF  42
009F:  BCF    03.5
....................  dout=concat(adresse,dis_data); 
00A0:  BSF    03.5
00A1:  MOVF   41,W
00A2:  MOVWF  46
00A3:  MOVF   42,W
00A4:  MOVWF  47
*
00C8:  MOVF   79,W
00C9:  MOVWF  45
00CA:  MOVF   78,W
00CB:  MOVWF  44
....................  output_low(LOAD); 
00CC:  BCF    06.1
00CD:  BCF    03.5
00CE:  BCF    06.1
....................  
....................  for (x=16;x>0;x--) 
00CF:  MOVLW  10
00D0:  BSF    03.5
00D1:  MOVWF  43
00D2:  MOVF   43,F
00D3:  BTFSC  03.2
00D4:  GOTO   0FD
....................  { 
....................   if (bit_test(dout,x-1)) output_high(DIN); 
00D5:  MOVLW  01
00D6:  SUBWF  43,W
00D7:  MOVWF  46
00D8:  MOVF   45,W
00D9:  MOVWF  7A
00DA:  MOVF   44,W
00DB:  MOVWF  79
00DC:  MOVF   46,W
00DD:  MOVWF  77
00DE:  BTFSC  03.2
00DF:  GOTO   0E5
00E0:  BCF    03.0
00E1:  RRF    7A,F
00E2:  RRF    79,F
00E3:  DECFSZ 77,F
00E4:  GOTO   0E0
00E5:  MOVF   79,W
00E6:  BTFSS  79.0
00E7:  GOTO   0ED
00E8:  BCF    06.0
00E9:  BCF    03.5
00EA:  BSF    06.0
00EB:  GOTO   0F0
00EC:  BSF    03.5
....................   else output_low(DIN); 
00ED:  BCF    06.0
00EE:  BCF    03.5
00EF:  BCF    06.0
....................   output_high(CLK); 
00F0:  BSF    03.5
00F1:  BCF    06.2
00F2:  BCF    03.5
00F3:  BSF    06.2
....................   delay_cycles(clk_delay); 
00F4:  NOP
....................   output_low(CLK); 
00F5:  BSF    03.5
00F6:  BCF    06.2
00F7:  BCF    03.5
00F8:  BCF    06.2
....................   delay_cycles(clk_delay); 
00F9:  NOP
00FA:  BSF    03.5
00FB:  DECF   43,F
00FC:  GOTO   0D2
....................  } 
....................  SSPEN=1; 
00FD:  BSF    03.6
00FE:  BSF    46.5
....................  output_high(LOAD); 
00FF:  BCF    03.6
0100:  BCF    06.1
0101:  BCF    03.5
0102:  BSF    06.1
0103:  RETURN
.................... } 
.................... //another variant of the display function if you use the hardware SPI 
.................... /*void display(char adresse,char dis_data) 
.................... { 
.................... output_low(LOAD); 
.................... spi_write(adresse); 
.................... delay_us(25); 
.................... spi_write(dis_data); 
.................... output_high(LOAD); 
.................... }*/ 
.................... //use this function to continously put data in the digits 
.................... //without bothering about incremanting the address 
.................... //the address increment is done automatically 
.................... void seg_putc(unsigned int8 c) 
.................... { 
....................    display(pos1,c); 
....................    if(pos1>=8) 
....................       pos1=1; 
....................    else 
....................       pos1++; 
.................... } 
....................  
.................... //Takes an array of 8 datas and put them on the digits 
.................... //the dp decides the position of the decimal point 
.................... //1 -> decimal point on 1st digit 
.................... //8 -> decimal point on 8th digit 
.................... void display_digits(unsigned int8 arr[],unsigned int8 dp) 
.................... { 
....................       unsigned int8 i; 
....................       //int decimal; 
....................       if(dp>8 || dp<1) 
....................          dp=0; 
....................       for(i=1;i<=8;i++) 
....................       { 
....................          if(dp==i) 
....................             display(i,arr[i-1]+0x80); 
....................          else 
....................             display(i,arr[i-1]+0x00); 
....................       } 
....................       pos1=1; 
.................... } 
.................... //Takes a character as argument and displays it on a 8x8 
.................... //Dot matrix display. Works only in mode 0 i.e. No decode 
.................... void display_char(char ch) 
.................... { 
....................    int char_offset=0; 
....................    int8 char_width=0; 
....................    int8 char_data[8]={0,0,0,0,0,0,0,0}; 
....................    int8 j=0; 
....................    unsigned int16 i=0; 
....................    unsigned int16 sum=0; 
....................    if(ch>=FIRST_CHAR && ch<=LAST_CHAR) 
....................    { 
....................       char_offset=ch-FIRST_CHAR; 
....................       char_width=font_width[char_offset]; 
....................       for(i=0;i<char_offset;i++) 
....................       { 
....................         sum=sum+font_width[i]; 
....................         //printf("%d+",font_width[i]); 
....................       } 
....................       //printf("\r\n\r\n%ld\r\n",sum); 
....................       j=((8-char_width)/2); 
....................       for(i=sum;i<sum+char_width;i++) 
....................       { 
....................          char_data[j]=font[i]; 
....................          //printf("(%d, %X), "i,font[i]); 
....................          j++; 
....................       } 
....................       //display_digits(char_data,0); 
....................       for(i=8;i>=1;i--) 
....................       { 
....................          //printf("%X, ",char_data[i-1]); 
....................          display(9-i,char_data[i-1]); 
....................       }         
....................    } 
.................... } 
.................... //Sets the text for scrolling. Call it to change the 
.................... //scrolling text. 
.................... void scroll_text(unsigned char* str) 
.................... { 
....................    int len=0; 
....................    len=strlen(str); 
....................    scroll_text_len=len; 
....................    scroll_chars=malloc(len+1); 
....................    strcpy(scroll_chars,str); 
.................... } 
.................... //keep on calling this function repetedly to scroll text 
.................... void start_scroll() 
.................... { 
....................    int char_offset=0; 
....................    int8 char_width=0; 
....................    int1 interspace=0; 
....................    unsigned int16 i=0; 
....................    unsigned int16 sum=0; 
....................    char ch=0; 
....................    ch=scroll_chars[cur_scroll_position]; 
....................    if(ch>=FIRST_CHAR && ch<=LAST_CHAR) 
....................    { 
....................       if(cur_letter_position==cur_letter_end_position) 
....................       { 
....................  
....................         if(temp_char_spacing<char_spacing) 
....................          { 
....................                interspace=1; 
....................                temp_char_spacing++; 
....................          } 
....................          else 
....................          { 
....................                interspace=0; 
....................                temp_char_spacing=0; 
....................                char_offset=ch-FIRST_CHAR; 
....................                char_width=font_width[char_offset]; 
....................                for(i=0;i<char_offset;i++) 
....................                  sum=sum+font_width[i]; 
....................                cur_letter_position=sum; 
....................                cur_letter_end_position=cur_letter_position+char_width;                
....................                cur_scroll_position++; 
....................                if(cur_scroll_position>=scroll_text_len) 
....................                   cur_scroll_position=0;             
....................          } 
....................       } 
....................       for(i=7; i>0; i--) 
....................           cur_char_data[i] = cur_char_data[i-1];       
....................       if(interspace==0) 
....................       { 
....................          cur_char_data[0]=font[cur_letter_end_position-1]; 
....................          cur_letter_end_position--; 
....................       } 
....................       else 
....................       { 
....................          cur_char_data[0]=0x00;; 
....................       } 
....................       for(i=1;i<=8;i++) 
....................       { 
....................          //printf("%X, ",cur_char_data[i-1]); 
....................          display(9-i,cur_char_data[i-1]); 
....................       }   
....................       //printf("\r\n"); 
....................    } 
.................... } 
.................... void put_number(unsigned char* str,int1 align=0,int1 pad_zeros=0) 
.................... { 
....................    unsigned int8 len=0; 
....................    int8 i=0,j=0; 
....................    unsigned int8 char_data[8]={0,0,0,0,0,0,0,0}; 
....................    len=strlen(str); 
....................    if(align==0) 
....................    { 
....................       for(i=0;i<len;i++) 
....................       { 
....................          if(str[i]=='.') 
....................          { 
....................             char_data[j-1]+=0x80; 
....................          } 
....................          else 
....................          { 
....................             if(str[i]>=48 && str[i]<=57) 
....................             { 
....................                char_data[j]=numbers[(str[i]-48)]; 
....................                j++; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       j=7; 
....................       //printf("%d",i); 
....................       for(i=len-1;;i--) 
....................       { 
....................          //printf("%d\r\n",i); 
....................          if(i==-1)  break; 
....................          if(str[i]=='.') 
....................          { 
....................             char_data[j]=numbers[(str[i-1]-48)]+0x80; 
....................             i--; 
....................             j--; 
....................          } 
....................          else 
....................          { 
....................             if(str[i]>=48 && str[i]<=57) 
....................             { 
....................                char_data[j]=numbers[(str[i]-48)]; 
....................                j--; 
....................             } 
....................          } 
....................       }    
....................       if(pad_zeros) 
....................       { 
....................          if(j!=-1) 
....................          for(i=0;i<=j;i++) 
....................             char_data[i]=0x3F; 
....................       } 
....................    } 
....................    display_digits(char_data,0); 
.................... } 
.................... //intialize the display driver chip 
.................... //it takes the argument decode that decides whether the digits are 
.................... //decoded using CODE B scheme or they are not decoded at all 
.................... //0 -> No decode 
.................... //1 -> Decode 
.................... void display_init(int1 decode) 
.................... { 
....................  output_low(CLK); 
*
015D:  BCF    06.2
015E:  BCF    03.5
015F:  BCF    06.2
....................  delay_us(1); 
0160:  NOP
....................  output_high(LOAD); 
0161:  BSF    03.5
0162:  BCF    06.1
0163:  BCF    03.5
0164:  BSF    06.1
....................  nd=1; 
0165:  BSF    39.0
....................  display(0x0B,0x07);  // scan limit - 8 columnas 
0166:  MOVLW  0B
0167:  BSF    03.5
0168:  MOVWF  41
0169:  MOVLW  07
016A:  MOVWF  42
016B:  BCF    03.5
016C:  CALL   041
....................  display(0x0C,0x01);  // Shutdown - normal mode 
016D:  MOVLW  0C
016E:  BSF    03.5
016F:  MOVWF  41
0170:  MOVLW  01
0171:  MOVWF  42
0172:  BCF    03.5
0173:  CALL   041
....................  if(!decode) 
0174:  BSF    03.5
0175:  MOVF   40,F
0176:  BTFSS  03.2
0177:  GOTO   17F
....................    display(0x09,0x00);  // decode mode = 0 
0178:  MOVLW  09
0179:  MOVWF  41
017A:  CLRF   42
017B:  BCF    03.5
017C:  CALL   041
017D:  GOTO   185
017E:  BSF    03.5
....................  else 
....................    display(0x09,0xFF);  // decode mode = 1 
017F:  MOVLW  09
0180:  MOVWF  41
0181:  MOVLW  FF
0182:  MOVWF  42
0183:  BCF    03.5
0184:  CALL   041
....................  display(0x0A,0x07);  // intensity 
0185:  MOVLW  0A
0186:  BSF    03.5
0187:  MOVWF  41
0188:  MOVLW  07
0189:  MOVWF  42
018A:  BCF    03.5
018B:  CALL   041
....................  nd=decode; 
018C:  BCF    39.0
018D:  BSF    03.5
018E:  BTFSS  40.0
018F:  GOTO   193
0190:  BCF    03.5
0191:  BSF    39.0
0192:  BSF    03.5
....................  pos1=1; 
0193:  MOVLW  01
0194:  BCF    03.5
0195:  MOVWF  3A
....................  //display(0x0F,0x00);  // test 
.................... } 
....................  
....................  
....................  
....................  
.................... void buzz() { 
....................     output_high(BUZZER); // Buzzer' a 
*
04CD:  BSF    03.5
04CE:  BCF    06.3
04CF:  BCF    03.5
04D0:  BSF    06.3
....................     delay_ms(250); 
04D1:  MOVLW  FA
04D2:  BSF    03.5
04D3:  MOVWF  46
04D4:  BCF    03.5
04D5:  CALL   288
....................     output_low(BUZZER); // Buzzer' kapat 
04D6:  BSF    03.5
04D7:  BCF    06.3
04D8:  BCF    03.5
04D9:  BCF    06.3
.................... } 
....................  
....................  
.................... void send_data(unsigned char address, unsigned char data) { 
....................    unsigned char i; 
....................    output_low(LOAD); // Veri gnderimini balat 
*
0104:  BSF    03.5
0105:  BCF    06.1
0106:  BCF    03.5
0107:  BCF    06.1
....................    for(i = 0; i < 8; i++) { // Adres gnderimi 
0108:  BSF    03.5
0109:  CLRF   4D
010A:  MOVF   4D,W
010B:  SUBLW  07
010C:  BTFSS  03.0
010D:  GOTO   130
....................       output_bit(DIN, (address >> (7 - i)) & 0x01); 
010E:  MOVF   4D,W
010F:  SUBLW  07
0110:  MOVWF  78
0111:  MOVF   4B,W
0112:  MOVWF  77
0113:  MOVF   78,F
0114:  BTFSC  03.2
0115:  GOTO   11A
0116:  BCF    03.0
0117:  RRF    77,F
0118:  DECFSZ 78,F
0119:  GOTO   116
011A:  MOVF   77,W
011B:  ANDLW  01
011C:  BTFSS  03.2
011D:  GOTO   122
011E:  BCF    03.5
011F:  BCF    06.0
0120:  GOTO   124
0121:  BSF    03.5
0122:  BCF    03.5
0123:  BSF    06.0
0124:  BSF    03.5
0125:  BCF    06.0
....................       output_high(CLK); // Saat sinyali 
0126:  BCF    06.2
0127:  BCF    03.5
0128:  BSF    06.2
....................       output_low(CLK); 
0129:  BSF    03.5
012A:  BCF    06.2
012B:  BCF    03.5
012C:  BCF    06.2
012D:  BSF    03.5
012E:  INCF   4D,F
012F:  GOTO   10A
....................    } 
....................    for(i = 0; i < 8; i++) { // Veri gnderimi 
0130:  CLRF   4D
0131:  MOVF   4D,W
0132:  SUBLW  07
0133:  BTFSS  03.0
0134:  GOTO   157
....................       output_bit(DIN, (data >> (7 - i)) & 0x01); 
0135:  MOVF   4D,W
0136:  SUBLW  07
0137:  MOVWF  78
0138:  MOVF   4C,W
0139:  MOVWF  77
013A:  MOVF   78,F
013B:  BTFSC  03.2
013C:  GOTO   141
013D:  BCF    03.0
013E:  RRF    77,F
013F:  DECFSZ 78,F
0140:  GOTO   13D
0141:  MOVF   77,W
0142:  ANDLW  01
0143:  BTFSS  03.2
0144:  GOTO   149
0145:  BCF    03.5
0146:  BCF    06.0
0147:  GOTO   14B
0148:  BSF    03.5
0149:  BCF    03.5
014A:  BSF    06.0
014B:  BSF    03.5
014C:  BCF    06.0
....................       output_high(CLK); // Saat sinyali 
014D:  BCF    06.2
014E:  BCF    03.5
014F:  BSF    06.2
....................       output_low(CLK); 
0150:  BSF    03.5
0151:  BCF    06.2
0152:  BCF    03.5
0153:  BCF    06.2
0154:  BSF    03.5
0155:  INCF   4D,F
0156:  GOTO   131
....................    } 
....................    output_high(LOAD); // Veri gnderimini durdur 
0157:  BCF    06.1
0158:  BCF    03.5
0159:  BSF    06.1
015A:  RETURN
.................... } 
....................  
.................... void settingsPorts() 
.................... { 
....................    display_init(0); 
015B:  BSF    03.5
015C:  CLRF   40
....................    set_tris_b(0x00); // B portunu k olarak ayarla 
*
0196:  MOVLW  00
0197:  BSF    03.5
0198:  MOVWF  06
....................    output_b(0x00); // B portunu temizle 
0199:  CLRF   06
019A:  BCF    03.5
019B:  CLRF   06
....................  
....................    set_tris_d(0xFF); // D portunu giri olarak ayarla 
019C:  MOVLW  FF
019D:  BSF    03.5
019E:  MOVWF  08
....................    output_d(0x00); // D portunu temizle 
019F:  CLRF   08
01A0:  BCF    03.5
01A1:  CLRF   08
....................  
....................    send_data(0x0F, 0x00); // Test modunu kapat 
01A2:  MOVLW  0F
01A3:  BSF    03.5
01A4:  MOVWF  4B
01A5:  CLRF   4C
01A6:  BCF    03.5
01A7:  CALL   104
....................    send_data(0x0C, 0x01); // Normal alma 
01A8:  MOVLW  0C
01A9:  BSF    03.5
01AA:  MOVWF  4B
01AB:  MOVLW  01
01AC:  MOVWF  4C
01AD:  BCF    03.5
01AE:  CALL   104
....................  
....................    send_data(0x0B, 0x07); // Tarama limiti = 8 haneli 
01AF:  MOVLW  0B
01B0:  BSF    03.5
01B1:  MOVWF  4B
01B2:  MOVLW  07
01B3:  MOVWF  4C
01B4:  BCF    03.5
01B5:  CALL   104
....................    send_data(0x0A, 0x0F); // Younluk ayar 
01B6:  MOVLW  0A
01B7:  BSF    03.5
01B8:  MOVWF  4B
01B9:  MOVLW  0F
01BA:  MOVWF  4C
01BB:  BCF    03.5
01BC:  CALL   104
....................    send_data(0x09, 0x00); // zmleme modu yok 
01BD:  MOVLW  09
01BE:  BSF    03.5
01BF:  MOVWF  4B
01C0:  CLRF   4C
01C1:  BCF    03.5
01C2:  CALL   104
01C3:  BCF    0A.3
01C4:  BCF    0A.4
01C5:  GOTO   532 (RETURN)
.................... } 
....................  
.................... unsigned char led_matrix[8] = {0, 0, 0, 0, 0, 0, 0, 0}; 
*
0529:  CLRF   3B
052A:  CLRF   3C
052B:  CLRF   3D
052C:  CLRF   3E
052D:  CLRF   3F
052E:  CLRF   40
052F:  CLRF   41
0530:  CLRF   42
....................  
.................... void turn_off_all_leds() { 
....................     for (unsigned char row = 1; row <= 8; row++) { 
*
01C6:  MOVLW  01
01C7:  BSF    03.5
01C8:  MOVWF  40
01C9:  MOVF   40,W
01CA:  SUBLW  08
01CB:  BTFSS  03.0
01CC:  GOTO   1E3
....................         led_matrix[row - 1] = 0x00; // Tm LED'leri kapatmak iin veri 
01CD:  MOVLW  01
01CE:  SUBWF  40,W
01CF:  ADDLW  3B
01D0:  MOVWF  04
01D1:  BCF    03.7
01D2:  CLRF   00
....................         send_data(row, led_matrix[row - 1]); 
01D3:  MOVLW  01
01D4:  SUBWF  40,W
01D5:  ADDLW  3B
01D6:  MOVWF  04
01D7:  BCF    03.7
01D8:  MOVF   00,W
01D9:  MOVWF  41
01DA:  MOVF   40,W
01DB:  MOVWF  4B
01DC:  MOVF   41,W
01DD:  MOVWF  4C
01DE:  BCF    03.5
01DF:  CALL   104
01E0:  BSF    03.5
01E1:  INCF   40,F
01E2:  GOTO   1C9
....................     } 
01E3:  BCF    03.5
01E4:  BCF    0A.3
01E5:  BCF    0A.4
01E6:  GOTO   534 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void turn_on_led(unsigned char row, unsigned char column) { 
....................     led_matrix[row - 1] |= 1 << (column - 1); // Belirli LED'i amak iin 
*
029D:  MOVLW  01
029E:  BSF    03.5
029F:  SUBWF  48,W
02A0:  ADDLW  3B
02A1:  MOVWF  04
02A2:  BCF    03.7
02A3:  MOVLW  01
02A4:  SUBWF  49,W
02A5:  MOVWF  78
02A6:  MOVLW  01
02A7:  MOVWF  77
02A8:  MOVF   78,F
02A9:  BTFSC  03.2
02AA:  GOTO   2AF
02AB:  BCF    03.0
02AC:  RLF    77,F
02AD:  DECFSZ 78,F
02AE:  GOTO   2AB
02AF:  MOVF   77,W
02B0:  IORWF  00,W
02B1:  MOVWF  00
....................     send_data(row, led_matrix[row - 1]); // Belirtilen satr ve stun deerine gre belirli bir LED'i yak 
02B2:  MOVLW  01
02B3:  SUBWF  48,W
02B4:  ADDLW  3B
02B5:  MOVWF  04
02B6:  BCF    03.7
02B7:  MOVF   00,W
02B8:  MOVWF  4A
02B9:  MOVF   48,W
02BA:  MOVWF  4B
02BB:  MOVF   4A,W
02BC:  MOVWF  4C
02BD:  BCF    03.5
02BE:  CALL   104
02BF:  RETURN
.................... } 
....................  
....................  
.................... void turn_off_led(unsigned char row, unsigned char column) { 
....................     led_matrix[row - 1] &= ~(1 << (column - 1)); // Belirli LED'i kapatmak iin 
02C0:  MOVLW  01
02C1:  BSF    03.5
02C2:  SUBWF  48,W
02C3:  ADDLW  3B
02C4:  MOVWF  04
02C5:  BCF    03.7
02C6:  MOVLW  01
02C7:  SUBWF  49,W
02C8:  MOVWF  78
02C9:  MOVLW  01
02CA:  MOVWF  77
02CB:  MOVF   78,F
02CC:  BTFSC  03.2
02CD:  GOTO   2D2
02CE:  BCF    03.0
02CF:  RLF    77,F
02D0:  DECFSZ 78,F
02D1:  GOTO   2CE
02D2:  MOVF   77,W
02D3:  XORLW  FF
02D4:  ANDWF  00,W
02D5:  MOVWF  00
....................     send_data(row, led_matrix[row - 1]); // Belirtilen satr ve stun deerine gre belirli bir LED'i sndr 
02D6:  MOVLW  01
02D7:  SUBWF  48,W
02D8:  ADDLW  3B
02D9:  MOVWF  04
02DA:  BCF    03.7
02DB:  MOVF   00,W
02DC:  MOVWF  4A
02DD:  MOVF   48,W
02DE:  MOVWF  4B
02DF:  MOVF   4A,W
02E0:  MOVWF  4C
02E1:  BCF    03.5
02E2:  CALL   104
02E3:  RETURN
.................... } 
....................  
.................... void turn_led(unsigned char row, unsigned char column, unsigned char led_state) { 
....................     if (led_state != 0) { 
....................         led_matrix[row - 1] |= 1 << (column - 1); // Belirli LED'i amak iin 
....................     } else { 
....................         led_matrix[row - 1] &= ~(1 << (column - 1)); // Belirli LED'i kapatmak iin 
....................     } 
....................     send_data(row, led_matrix[row - 1]); // Belirtilen satr ve stun deerine gre belirli bir LED'i yak veya sndr 
.................... } 
....................  
....................  
.................... /* 
.................... void turn_led(unsigned char row, unsigned char column, unsigned char led_state) { 
....................     unsigned char LED_ON = (1 << (column - 1)); 
....................     unsigned char LED_OFF = 0x00; 
....................    
....................     if (led_state != 0) { 
....................         send_data(row, LED_ON); // Belirtilen satr ve stun deerine gre belirli bir LED'i yak 
....................     } else { 
....................         send_data(row, LED_OFF); // Belirtilen satr ve stun deerindeki LED'i sndr 
....................     } 
.................... } 
....................  
.................... */ 
....................  
.................... unsigned char level = 1; 
.................... unsigned char randLEDs[16][2]; 
.................... unsigned char selected_leds[16][2]; 
.................... unsigned char selected_led_count = 0; 
.................... unsigned char isItPLAYERsTurn = 0; 
.................... unsigned char row = 1; 
.................... unsigned char column = 1; 
....................  
.................... void generateRandomLEDs() {   // follows lollipop 
....................  
....................     srand(level); 
02E4:  BSF    03.5
02E5:  CLRF   49
02E6:  CLRF   48
02E7:  CLRF   47
02E8:  BCF    03.5
02E9:  MOVF   43,W
02EA:  BSF    03.5
02EB:  MOVWF  46
....................  
....................     for (int j = 0; j < level; j++) { 
*
02FB:  BSF    03.5
02FC:  CLRF   40
02FD:  BCF    03.5
02FE:  MOVF   43,W
02FF:  BSF    03.5
0300:  SUBWF  40,W
0301:  BTFSC  03.0
0302:  GOTO   34F
....................         unsigned char a, b; 
....................         int positionAlreadySelected; 
....................  
....................         do { 
....................             positionAlreadySelected = 0; 
0303:  CLRF   43
....................             a = 1 + rand() % 8; 
0304:  BCF    03.5
0305:  CALL   1E7
0306:  MOVF   79,W
0307:  BSF    03.5
0308:  MOVWF  47
0309:  MOVF   78,W
030A:  MOVWF  46
030B:  ANDLW  07
030C:  MOVWF  77
030D:  CLRF   7A
030E:  MOVF   77,W
030F:  ADDLW  01
0310:  MOVWF  41
....................             b = 1 + rand() % 8; 
0311:  BCF    03.5
0312:  CALL   1E7
0313:  MOVF   79,W
0314:  BSF    03.5
0315:  MOVWF  47
0316:  MOVF   78,W
0317:  MOVWF  46
0318:  ANDLW  07
0319:  MOVWF  77
031A:  CLRF   7A
031B:  MOVF   77,W
031C:  ADDLW  01
031D:  MOVWF  42
....................  
....................             // Seilen konumu daha nce seilmi konumlarla kontrol et 
....................             for (int k = 0; k < j; k++) { 
031E:  CLRF   44
031F:  MOVF   40,W
0320:  SUBWF  44,W
0321:  BTFSC  03.0
0322:  GOTO   33B
....................                 if (randLEDs[k][0] == a && randLEDs[k][1] == b) { 
0323:  BCF    03.0
0324:  RLF    44,W
0325:  ADDLW  44
0326:  MOVWF  04
0327:  BCF    03.7
0328:  MOVF   41,W
0329:  SUBWF  00,W
032A:  BTFSS  03.2
032B:  GOTO   339
032C:  BCF    03.0
032D:  RLF    44,W
032E:  ADDLW  01
032F:  ADDLW  44
0330:  MOVWF  04
0331:  BCF    03.7
0332:  MOVF   42,W
0333:  SUBWF  00,W
0334:  BTFSS  03.2
0335:  GOTO   339
....................                     positionAlreadySelected = 1; 
0336:  MOVLW  01
0337:  MOVWF  43
....................                     break; 
0338:  GOTO   33B
....................                 } 
0339:  INCF   44,F
033A:  GOTO   31F
....................             } 
....................         } while (positionAlreadySelected); 
033B:  MOVF   43,F
033C:  BTFSS  03.2
033D:  GOTO   303
....................  
....................         randLEDs[j][0] = a; 
033E:  BCF    03.0
033F:  RLF    40,W
0340:  ADDLW  44
0341:  MOVWF  04
0342:  BCF    03.7
0343:  MOVF   41,W
0344:  MOVWF  00
....................         randLEDs[j][1] = b; 
0345:  BCF    03.0
0346:  RLF    40,W
0347:  ADDLW  01
0348:  ADDLW  44
0349:  MOVWF  04
034A:  BCF    03.7
034B:  MOVF   42,W
034C:  MOVWF  00
034D:  INCF   40,F
034E:  GOTO   2FD
....................  
....................     } 
....................  
....................     for (int i = 0; i < level; i++) { 
034F:  CLRF   45
0350:  BCF    03.5
0351:  MOVF   43,W
0352:  BSF    03.5
0353:  SUBWF  45,W
0354:  BTFSC  03.0
0355:  GOTO   38E
....................         delay_ms(75); 
0356:  MOVLW  4B
0357:  MOVWF  46
0358:  BCF    03.5
0359:  CALL   288
....................         turn_on_led(randLEDs[i][0], randLEDs[i][1]); 
035A:  BCF    03.0
035B:  BSF    03.5
035C:  RLF    45,W
035D:  ADDLW  44
035E:  MOVWF  04
035F:  BCF    03.7
0360:  MOVF   00,W
0361:  MOVWF  46
0362:  BCF    03.0
0363:  RLF    45,W
0364:  ADDLW  01
0365:  ADDLW  44
0366:  MOVWF  04
0367:  BCF    03.7
0368:  MOVF   00,W
0369:  MOVWF  47
036A:  MOVF   46,W
036B:  MOVWF  48
036C:  MOVF   47,W
036D:  MOVWF  49
036E:  BCF    03.5
036F:  CALL   29D
....................         delay_ms(125); 
0370:  MOVLW  7D
0371:  BSF    03.5
0372:  MOVWF  46
0373:  BCF    03.5
0374:  CALL   288
....................         turn_off_led(randLEDs[i][0], randLEDs[i][1]); 
0375:  BCF    03.0
0376:  BSF    03.5
0377:  RLF    45,W
0378:  ADDLW  44
0379:  MOVWF  04
037A:  BCF    03.7
037B:  MOVF   00,W
037C:  MOVWF  46
037D:  BCF    03.0
037E:  RLF    45,W
037F:  ADDLW  01
0380:  ADDLW  44
0381:  MOVWF  04
0382:  BCF    03.7
0383:  MOVF   00,W
0384:  MOVWF  47
0385:  MOVF   46,W
0386:  MOVWF  48
0387:  MOVF   47,W
0388:  MOVWF  49
0389:  BCF    03.5
038A:  CALL   2C0
038B:  BSF    03.5
038C:  INCF   45,F
038D:  GOTO   350
....................  
....................     } 
....................      
....................     isItPLAYERsTurn = 1; 
038E:  MOVLW  01
038F:  BCF    03.5
0390:  MOVWF  65
0391:  BCF    0A.3
0392:  BCF    0A.4
0393:  GOTO   538 (RETURN)
.................... } 
....................  
....................  
....................  
.................... int check_selected_leds() { 
....................     for (unsigned char i = 0; i < level; i++) { 
*
03B8:  BSF    03.5
03B9:  CLRF   40
03BA:  BCF    03.5
03BB:  MOVF   43,W
03BC:  BSF    03.5
03BD:  SUBWF  40,W
03BE:  BTFSC  03.0
03BF:  GOTO   3E7
....................         if (selected_leds[i][0] != randLEDs[i][0] || selected_leds[i][1] != randLEDs[i][1]) { 
03C0:  BCF    03.0
03C1:  RLF    40,W
03C2:  ADDLW  A0
03C3:  MOVWF  04
03C4:  BCF    03.7
03C5:  MOVF   00,W
03C6:  MOVWF  41
03C7:  BCF    03.0
03C8:  RLF    40,W
03C9:  ADDLW  44
03CA:  MOVWF  04
03CB:  BCF    03.7
03CC:  MOVF   00,W
03CD:  SUBWF  41,W
03CE:  BTFSS  03.2
03CF:  GOTO   3E2
03D0:  BCF    03.0
03D1:  RLF    40,W
03D2:  ADDLW  01
03D3:  ADDLW  A0
03D4:  MOVWF  04
03D5:  BCF    03.7
03D6:  MOVF   00,W
03D7:  MOVWF  41
03D8:  BCF    03.0
03D9:  RLF    40,W
03DA:  ADDLW  01
03DB:  ADDLW  44
03DC:  MOVWF  04
03DD:  BCF    03.7
03DE:  MOVF   00,W
03DF:  SUBWF  41,W
03E0:  BTFSC  03.2
03E1:  GOTO   3E5
....................             return 0; 
03E2:  MOVLW  00
03E3:  MOVWF  78
03E4:  GOTO   3E9
....................         } 
03E5:  INCF   40,F
03E6:  GOTO   3BA
....................     } 
....................     return 1; 
03E7:  MOVLW  01
03E8:  MOVWF  78
03E9:  BCF    03.5
03EA:  RETURN
.................... } 
....................  
....................  
....................  
....................  
.................... // LED'in seilip seilmediini kontrol eden fonksiyon ve mr. beast ok iyi 
.................... int is_selected(unsigned char row, unsigned char column) { 
....................    for (unsigned char i = 0; i < selected_led_count; i++) { 
*
0394:  BSF    03.5
0395:  CLRF   42
0396:  BCF    03.5
0397:  MOVF   64,W
0398:  BSF    03.5
0399:  SUBWF  42,W
039A:  BTFSC  03.0
039B:  GOTO   3B4
....................       if (selected_leds[i][0] == row && selected_leds[i][1] == column) { 
039C:  BCF    03.0
039D:  RLF    42,W
039E:  ADDLW  A0
039F:  MOVWF  04
03A0:  BCF    03.7
03A1:  MOVF   40,W
03A2:  SUBWF  00,W
03A3:  BTFSS  03.2
03A4:  GOTO   3B2
03A5:  BCF    03.0
03A6:  RLF    42,W
03A7:  ADDLW  01
03A8:  ADDLW  A0
03A9:  MOVWF  04
03AA:  BCF    03.7
03AB:  MOVF   41,W
03AC:  SUBWF  00,W
03AD:  BTFSS  03.2
03AE:  GOTO   3B2
....................          return 1; 
03AF:  MOVLW  01
03B0:  MOVWF  78
03B1:  GOTO   3B6
....................       } 
03B2:  INCF   42,F
03B3:  GOTO   396
....................    } 
....................    return 0; 
03B4:  MOVLW  00
03B5:  MOVWF  78
03B6:  BCF    03.5
03B7:  RETURN
.................... } 
....................  
.................... void playerMovement() { 
....................       // Sa (RIGHT) butonuna basldnda 
....................       if (input(BUTTON_RIGHT)) { 
*
03EB:  BSF    03.5
03EC:  BSF    08.3
03ED:  BCF    03.5
03EE:  BTFSS  08.3
03EF:  GOTO   41A
....................           
....................          if (!is_selected(row, column)) { 
03F0:  MOVF   66,W
03F1:  BSF    03.5
03F2:  MOVWF  40
03F3:  BCF    03.5
03F4:  MOVF   67,W
03F5:  BSF    03.5
03F6:  MOVWF  41
03F7:  BCF    03.5
03F8:  CALL   394
03F9:  MOVF   78,F
03FA:  BTFSS  03.2
03FB:  GOTO   405
....................             turn_off_led(row,column); 
03FC:  MOVF   66,W
03FD:  BSF    03.5
03FE:  MOVWF  48
03FF:  BCF    03.5
0400:  MOVF   67,W
0401:  BSF    03.5
0402:  MOVWF  49
0403:  BCF    03.5
0404:  CALL   2C0
....................          } 
....................          column++; 
0405:  INCF   67,F
....................          if (column > 8) {  
0406:  MOVF   67,W
0407:  SUBLW  08
0408:  BTFSC  03.0
0409:  GOTO   40C
....................             column = 1; 
040A:  MOVLW  01
040B:  MOVWF  67
....................          } 
....................          turn_on_led(row, column); 
040C:  MOVF   66,W
040D:  BSF    03.5
040E:  MOVWF  48
040F:  BCF    03.5
0410:  MOVF   67,W
0411:  BSF    03.5
0412:  MOVWF  49
0413:  BCF    03.5
0414:  CALL   29D
....................          delay_ms(75); 
0415:  MOVLW  4B
0416:  BSF    03.5
0417:  MOVWF  46
0418:  BCF    03.5
0419:  CALL   288
....................       } 
....................        
....................       // Sol (LEFT) butonuna basldnda 
....................       if (input(BUTTON_LEFT)) { 
041A:  BSF    03.5
041B:  BSF    08.1
041C:  BCF    03.5
041D:  BTFSS  08.1
041E:  GOTO   446
....................        
....................          if (!is_selected(row, column)) { 
041F:  MOVF   66,W
0420:  BSF    03.5
0421:  MOVWF  40
0422:  BCF    03.5
0423:  MOVF   67,W
0424:  BSF    03.5
0425:  MOVWF  41
0426:  BCF    03.5
0427:  CALL   394
0428:  MOVF   78,F
0429:  BTFSS  03.2
042A:  GOTO   434
....................             turn_off_led(row, column); 
042B:  MOVF   66,W
042C:  BSF    03.5
042D:  MOVWF  48
042E:  BCF    03.5
042F:  MOVF   67,W
0430:  BSF    03.5
0431:  MOVWF  49
0432:  BCF    03.5
0433:  CALL   2C0
....................          } 
....................          column--; 
0434:  DECFSZ 67,F
....................          if (column < 1) {  
0435:  GOTO   438
....................             column = 8; 
0436:  MOVLW  08
0437:  MOVWF  67
....................          } 
....................          turn_on_led(row, column); 
0438:  MOVF   66,W
0439:  BSF    03.5
043A:  MOVWF  48
043B:  BCF    03.5
043C:  MOVF   67,W
043D:  BSF    03.5
043E:  MOVWF  49
043F:  BCF    03.5
0440:  CALL   29D
....................          delay_ms(75); 
0441:  MOVLW  4B
0442:  BSF    03.5
0443:  MOVWF  46
0444:  BCF    03.5
0445:  CALL   288
....................       } 
....................        
....................       // Yukar (UP) butonuna basldnda 
....................       if (input(BUTTON_UP)) { 
0446:  BSF    03.5
0447:  BSF    08.2
0448:  BCF    03.5
0449:  BTFSS  08.2
044A:  GOTO   472
....................           
....................          if (!is_selected(row, column)) { 
044B:  MOVF   66,W
044C:  BSF    03.5
044D:  MOVWF  40
044E:  BCF    03.5
044F:  MOVF   67,W
0450:  BSF    03.5
0451:  MOVWF  41
0452:  BCF    03.5
0453:  CALL   394
0454:  MOVF   78,F
0455:  BTFSS  03.2
0456:  GOTO   460
....................             turn_off_led(row, column); 
0457:  MOVF   66,W
0458:  BSF    03.5
0459:  MOVWF  48
045A:  BCF    03.5
045B:  MOVF   67,W
045C:  BSF    03.5
045D:  MOVWF  49
045E:  BCF    03.5
045F:  CALL   2C0
....................          } 
....................          row--; 
0460:  DECFSZ 66,F
....................          if (row < 1) {  
0461:  GOTO   464
....................             row = 8; 
0462:  MOVLW  08
0463:  MOVWF  66
....................          } 
....................          turn_on_led(row, column); 
0464:  MOVF   66,W
0465:  BSF    03.5
0466:  MOVWF  48
0467:  BCF    03.5
0468:  MOVF   67,W
0469:  BSF    03.5
046A:  MOVWF  49
046B:  BCF    03.5
046C:  CALL   29D
....................          delay_ms(75); 
046D:  MOVLW  4B
046E:  BSF    03.5
046F:  MOVWF  46
0470:  BCF    03.5
0471:  CALL   288
....................       } 
....................        
....................       // Aa (DOWN) butonuna basldnda 
....................       if (input(BUTTON_DOWN)) { 
0472:  BSF    03.5
0473:  BSF    08.4
0474:  BCF    03.5
0475:  BTFSS  08.4
0476:  GOTO   4A1
....................           
....................          if (!is_selected(row, column)) { 
0477:  MOVF   66,W
0478:  BSF    03.5
0479:  MOVWF  40
047A:  BCF    03.5
047B:  MOVF   67,W
047C:  BSF    03.5
047D:  MOVWF  41
047E:  BCF    03.5
047F:  CALL   394
0480:  MOVF   78,F
0481:  BTFSS  03.2
0482:  GOTO   48C
....................             turn_off_led(row, column); 
0483:  MOVF   66,W
0484:  BSF    03.5
0485:  MOVWF  48
0486:  BCF    03.5
0487:  MOVF   67,W
0488:  BSF    03.5
0489:  MOVWF  49
048A:  BCF    03.5
048B:  CALL   2C0
....................          } 
....................          row++; 
048C:  INCF   66,F
....................          if (row > 8) {  
048D:  MOVF   66,W
048E:  SUBLW  08
048F:  BTFSC  03.0
0490:  GOTO   493
....................             row = 1; 
0491:  MOVLW  01
0492:  MOVWF  66
....................          } 
....................          turn_on_led(row, column); 
0493:  MOVF   66,W
0494:  BSF    03.5
0495:  MOVWF  48
0496:  BCF    03.5
0497:  MOVF   67,W
0498:  BSF    03.5
0499:  MOVWF  49
049A:  BCF    03.5
049B:  CALL   29D
....................          delay_ms(75); 
049C:  MOVLW  4B
049D:  BSF    03.5
049E:  MOVWF  46
049F:  BCF    03.5
04A0:  CALL   288
....................       } 
....................        
....................       if(input(BUTTON_SELECT)) 
04A1:  BSF    03.5
04A2:  BSF    08.0
04A3:  BCF    03.5
04A4:  BTFSS  08.0
04A5:  GOTO   4E6
....................       { 
....................        
....................          //led_matrix[row - 1] |= 1 << (column - 1); 
....................          //send_data(row, led_matrix[row - 1]); 
....................          turn_on_led(row,column); 
04A6:  MOVF   66,W
04A7:  BSF    03.5
04A8:  MOVWF  48
04A9:  BCF    03.5
04AA:  MOVF   67,W
04AB:  BSF    03.5
04AC:  MOVWF  49
04AD:  BCF    03.5
04AE:  CALL   29D
....................           
....................          // Konumu diziye kaydet 
....................          selected_leds[selected_led_count][0] = row; 
04AF:  BCF    03.0
04B0:  RLF    64,W
04B1:  ADDLW  A0
04B2:  MOVWF  04
04B3:  BCF    03.7
04B4:  MOVF   66,W
04B5:  MOVWF  00
....................          selected_leds[selected_led_count][1] = column; 
04B6:  BCF    03.0
04B7:  RLF    64,W
04B8:  ADDLW  01
04B9:  ADDLW  A0
04BA:  MOVWF  04
04BB:  BCF    03.7
04BC:  MOVF   67,W
04BD:  MOVWF  00
....................          selected_led_count++; 
04BE:  INCF   64,F
....................          delay_ms(75); 
04BF:  MOVLW  4B
04C0:  BSF    03.5
04C1:  MOVWF  46
04C2:  BCF    03.5
04C3:  CALL   288
....................          if (selected_led_count == level)  
04C4:  MOVF   43,W
04C5:  SUBWF  64,W
04C6:  BTFSS  03.2
04C7:  GOTO   4E6
....................          { 
....................             if(!check_selected_leds()) 
04C8:  CALL   3B8
04C9:  MOVF   78,F
04CA:  BTFSS  03.2
04CB:  GOTO   4DB
....................             { 
....................                isItPLAYERsTurn = 0; 
04CC:  CLRF   65
....................                buzz(); 
....................             } 
*
04DA:  GOTO   4E1
....................             else if (check_selected_leds())  
04DB:  CALL   3B8
04DC:  MOVF   78,F
04DD:  BTFSC  03.2
04DE:  GOTO   4E1
....................             { 
....................                level++; 
04DF:  INCF   43,F
....................                isItPLAYERsTurn = 0; 
04E0:  CLRF   65
....................             } 
....................              
....................             delay_ms(75); 
04E1:  MOVLW  4B
04E2:  BSF    03.5
04E3:  MOVWF  46
04E4:  BCF    03.5
04E5:  CALL   288
....................          } 
....................       } 
04E6:  BCF    0A.3
04E7:  BCF    0A.4
04E8:  GOTO   545 (RETURN)
.................... } 
....................  
....................  
.................... void main() { 
04E9:  CLRF   28
04EA:  CLRF   2A
04EB:  CLRF   29
04EC:  CLRF   2C
04ED:  CLRF   2B
04EE:  CLRF   2D
04EF:  CLRF   38
04F0:  MOVLW  01
04F1:  MOVWF  43
04F2:  CLRF   64
04F3:  CLRF   65
04F4:  MOVWF  66
04F5:  MOVWF  67
04F6:  BSF    03.5
04F7:  BSF    1F.0
04F8:  BSF    1F.1
04F9:  BSF    1F.2
04FA:  BCF    1F.3
04FB:  MOVLW  07
04FC:  MOVWF  1C
04FD:  BCF    03.5
04FE:  CLRF   27
04FF:  MOVLW  68
0500:  MOVWF  26
0501:  MOVLW  0C
0502:  MOVWF  68
0503:  CLRF   6A
0504:  MOVLW  D3
0505:  MOVWF  69
0506:  MOVLW  1A
0507:  BSF    03.5
0508:  MOVWF  53
0509:  MOVLW  01
050A:  MOVWF  55
050B:  MOVLW  10
050C:  MOVWF  54
050D:  MOVLW  5D
050E:  BCF    03.5
050F:  BSF    03.6
0510:  MOVWF  10
0511:  MOVLW  01
0512:  MOVWF  12
0513:  MOVLW  90
0514:  MOVWF  11
0515:  MOVLW  5D
0516:  BSF    03.5
0517:  MOVWF  10
0518:  CLRF   12
0519:  CLRF   11
051A:  BCF    03.5
051B:  BCF    03.6
051C:  BCF    03.7
051D:  MOVLW  1F
051E:  ANDWF  03,F
....................  
....................    settingsPorts(); 
*
0531:  GOTO   15B
....................  
....................    while(1){ 
....................     
....................       selected_led_count = 0; 
0532:  CLRF   64
....................        
....................       turn_off_all_leds(); 
0533:  GOTO   1C6
....................       row = 1; 
0534:  MOVLW  01
0535:  MOVWF  66
....................       column = 1; 
0536:  MOVWF  67
....................  
....................       generateRandomLEDs(); 
0537:  GOTO   2E4
....................       turn_on_led(row,column); 
0538:  MOVF   66,W
0539:  BSF    03.5
053A:  MOVWF  48
053B:  BCF    03.5
053C:  MOVF   67,W
053D:  BSF    03.5
053E:  MOVWF  49
053F:  BCF    03.5
0540:  CALL   29D
....................  
....................     
....................       while (isItPLAYERsTurn) { 
0541:  MOVF   65,F
0542:  BTFSC  03.2
0543:  GOTO   546
....................          playerMovement(); 
0544:  GOTO   3EB
0545:  GOTO   541
....................       } 
0546:  GOTO   532
....................    } 
.................... } 
....................  
0547:  SLEEP
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
